import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import os

# =========================
# 0) 입력: 손글씨 X 이미지 → 10x10 grayscale → 0~1 normalize
# =========================
# (A) 사용자가 실제 이미지 파일을 업로드한 경우: 아래 경로만 맞춰주세요.
# 예: /content/X_image_1.jpg
IMG_PATH = "/content/test_image_2.jpg"

def load_or_make_x(img_path, size=(10,10)):
    if os.path.exists(img_path):
        img = Image.open(img_path).convert("L").resize(size, Image.Resampling.BILINEAR)
        x = np.array(img, dtype=np.float32) / 255.0  # 0~1 normalize
        return x, f"Loaded image: {img_path}"
    else:
        # (B) 파일이 없으면: 데모용 10x10 "X" 패턴 생성 (binary 기반)
        demo = np.zeros(size, dtype=np.float32)
        for i in range(size[0]):
            demo[i, i] = 1.0
            demo[i, size[1]-1-i] = 1.0
        # 배경은 밝게(1), 글자는 어둡게(0)인 그레이스케일처럼 보이도록 반전
        x = 1.0 - demo
        return x, "Demo X (synthetic) used because IMG_PATH not found"

x10, msg = load_or_make_x(IMG_PATH, size=(10,10))
print(msg)
print("\n[Step 0] Input 10x10 (normalized 0~1):")
print(np.round(x10, 3))

plt.figure(figsize=(4,4))
plt.imshow(x10, cmap="gray", vmin=0, vmax=1)
plt.title("Step 0: Input (10x10, 0~1)")
plt.axis("off")
plt.show()

# =========================
# 1) 3x3 랜덤 커널 생성 (0~1), Convolution (stride=1, valid)
# =========================
np.random.seed(42)  # 재현성(원하면 지워도 됨)
kernel = np.random.rand(3,3).astype(np.float32)  # 0~1
print("\n[Step 1] Random 3x3 kernel (0~1):")
print(np.round(kernel, 3))

def conv2d_valid_stride1(img, k):
    H, W = img.shape
    kh, kw = k.shape
    out_h = H - kh + 1
    out_w = W - kw + 1
    out = np.zeros((out_h, out_w), dtype=np.float32)
    for i in range(out_h):
        for j in range(out_w):
            patch = img[i:i+kh, j:j+kw]
            out[i,j] = np.sum(patch * k)
    return out

conv = conv2d_valid_stride1(x10, kernel)  # 8x8
print("\n[Step 1] Convolution output (8x8):")
print(np.round(conv, 3))

plt.figure(figsize=(4,4))
plt.imshow(conv, cmap="gray")
plt.title("Step 1: Conv (8x8)")
plt.axis("off")
plt.show()

# =========================
# 2) ReLU 적용
# =========================
relu1 = np.maximum(0.0, conv)
print("\n[Step 2] ReLU(Conv) output (8x8):")
print(np.round(relu1, 3))

plt.figure(figsize=(4,4))
plt.imshow(relu1, cmap="gray")
plt.title("Step 2: ReLU (8x8)")
plt.axis("off")
plt.show()

# =========================
# 3) Max Pooling (2x2, stride=2) → 4x4
# =========================
def maxpool2d(img, pool=2, stride=2):
    H, W = img.shape
    out_h = (H - pool)//stride + 1
    out_w = (W - pool)//stride + 1
    out = np.zeros((out_h, out_w), dtype=np.float32)
    for i in range(out_h):
        for j in range(out_w):
            r = i*stride
            c = j*stride
            window = img[r:r+pool, c:c+pool]
            out[i,j] = np.max(window)
    return out

pool1 = maxpool2d(relu1, pool=2, stride=2)  # 4x4
print("\n[Step 3] MaxPool(2x2, stride=2) output (4x4):")
print(np.round(pool1, 3))

plt.figure(figsize=(4,4))
plt.imshow(pool1, cmap="gray")
plt.title("Step 3: MaxPool (4x4)")
plt.axis("off")
plt.show()

# =========================
# 4) (요청대로) feature map에 다시 ReLU 적용 (이미 양수지만 단계 시연)
# =========================
relu2 = np.maximum(0.0, pool1)
print("\n[Step 4] ReLU(after Pool) output (4x4):")
print(np.round(relu2, 3))

plt.figure(figsize=(4,4))
plt.imshow(relu2, cmap="gray")
plt.title("Step 4: ReLU (4x4)")
plt.axis("off")
plt.show()

# =========================
# 5) 다시 Max Pooling (2x2, stride=2) → 2x2
# =========================
pool2 = maxpool2d(relu2, pool=2, stride=2)  # 2x2
print("\n[Step 5] MaxPool(2x2, stride=2) output (2x2):")
print(np.round(pool2, 3))

plt.figure(figsize=(3,3))
plt.imshow(pool2, cmap="gray")
plt.title("Step 5: MaxPool (2x2)")
plt.axis("off")
plt.show()

# =========================
# 6) 2x2 특징맵 → 1x4 특징벡터(flatten)
# =========================
feat_vec = pool2.reshape(1, -1)  # (1,4)
print("\n[Step 6] Flatten feature vector (1x4):")
print(np.round(feat_vec, 3))
plt.show()
import numpy as np
import matplotlib.pyplot as plt

# ---------------------------------------------------------
# (전제) x10: 10x10 입력(0~1 normalize)이 이미 만들어져 있어야 합니다.
# 위에서 사용한 함수(conv2d_valid_stride1, maxpool2d)도 이미 정의되어 있어야 합니다.
# ---------------------------------------------------------

np.random.seed(42)  # 재현성(원하면 변경/삭제)

num_kernels = 3
kernels = np.random.rand(num_kernels, 3, 3).astype(np.float32)  # 3개 커널 (0~1)

def relu(x):
    return np.maximum(0.0, x)

all_feature_maps_2x2 = []
all_feat_vecs_1x4 = []

plt.figure(figsize=(12, 3))

for k_idx in range(num_kernels):
    k = kernels[k_idx]

    # 1) Conv (8x8)
    conv = conv2d_valid_stride1(x10, k)

    # 2) ReLU (8x8)
    r1 = relu(conv)

    # 3) MaxPool -> 4x4
    p1 = maxpool2d(r1, pool=2, stride=2)

    # 4) ReLU -> 4x4
    r2 = relu(p1)

    # 5) MaxPool -> 2x2
    p2 = maxpool2d(r2, pool=2, stride=2)

    # 6) Flatten -> 1x4
    v = p2.reshape(1, -1)

    all_feature_maps_2x2.append(p2)
    all_feat_vecs_1x4.append(v)

    # 각 커널의 최종 2x2 특징맵 시각화
    plt.subplot(1, num_kernels, k_idx+1)
    plt.imshow(p2, cmap="gray")
    plt.title(f"Kernel {k_idx+1}\n2x2 map")
    plt.axis("off")

    print(f"\n===== Kernel {k_idx+1} (3x3, 0~1) =====")
    print(np.round(k, 3))
    print(f"[Kernel {k_idx+1}] Final 2x2 feature map:")
    print(np.round(p2, 3))
    print(f"[Kernel {k_idx+1}] Flatten (1x4):")
    print(np.round(v, 3))

plt.tight_layout()
plt.show()

# 3개의 (1x4)를 이어붙여 (1x12)
feat_1x12 = np.concatenate(all_feat_vecs_1x4, axis=1)  # (1, 12)

print("\n==============================")
print("[Final] Flatten feature vector (1x12):")
print(np.round(feat_1x12, 3))
print("Shape:", feat_1x12.shape)
