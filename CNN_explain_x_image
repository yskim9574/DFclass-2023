import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import os

# =========================
# 0) 입력: 손글씨 X 이미지 → 10x10 grayscale → 0~1 normalize
# =========================
# (A) 사용자가 실제 이미지 파일을 업로드한 경우: 아래 경로만 맞춰주세요.
# 예: /content/X_image_1.jpg
IMG_PATH = "/content/x_image.jpg"

def load_or_make_x(img_path, size=(10,10)):
    if os.path.exists(img_path):
        img = Image.open(img_path).convert("L").resize(size, Image.Resampling.BILINEAR)
        x = np.array(img, dtype=np.float32) / 255.0  # 0~1 normalize
        return x, f"Loaded image: {img_path}"
    else:
        # (B) 파일이 없으면: 데모용 10x10 "X" 패턴 생성 (binary 기반)
        demo = np.zeros(size, dtype=np.float32)
        for i in range(size[0]):
            demo[i, i] = 1.0
            demo[i, size[1]-1-i] = 1.0
        # 배경은 밝게(1), 글자는 어둡게(0)인 그레이스케일처럼 보이도록 반전
        x = 1.0 - demo
        return x, "Demo X (synthetic) used because IMG_PATH not found"

x10, msg = load_or_make_x(IMG_PATH, size=(10,10))
print(msg)
print("\n[Step 0] Input 10x10 (normalized 0~1):")
print(np.round(x10, 3))

plt.figure(figsize=(4,4))
plt.imshow(x10, cmap="gray", vmin=0, vmax=1)
plt.title("Step 0: Input (10x10, 0~1)")
plt.axis("off")
plt.show()

# =========================
# 1) 3x3 랜덤 커널 생성 (0~1), Convolution (stride=1, valid)
# =========================
np.random.seed(42)  # 재현성(원하면 지워도 됨)
kernel = np.random.rand(3,3).astype(np.float32)  # 0~1
print("\n[Step 1] Random 3x3 kernel (0~1):")
print(np.round(kernel, 3))

def conv2d_valid_stride1(img, k):
    H, W = img.shape
    kh, kw = k.shape
    out_h = H - kh + 1
    out_w = W - kw + 1
    out = np.zeros((out_h, out_w), dtype=np.float32)
    for i in range(out_h):
        for j in range(out_w):
            patch = img[i:i+kh, j:j+kw]
            out[i,j] = np.sum(patch * k)
    return out

conv = conv2d_valid_stride1(x10, kernel)  # 8x8
print("\n[Step 1] Convolution output (8x8):")
print(np.round(conv, 3))

plt.figure(figsize=(4,4))
plt.imshow(conv, cmap="gray")
plt.title("Step 1: Conv (8x8)")
plt.axis("off")
plt.show()

# =========================
# 2) ReLU 적용
# =========================
relu1 = np.maximum(0.0, conv)
print("\n[Step 2] ReLU(Conv) output (8x8):")
print(np.round(relu1, 3))

plt.figure(figsize=(4,4))
plt.imshow(relu1, cmap="gray")
plt.title("Step 2: ReLU (8x8)")
plt.axis("off")
plt.show()

# =========================
# 3) Max Pooling (2x2, stride=2) → 4x4
# =========================
def maxpool2d(img, pool=2, stride=2):
    H, W = img.shape
    out_h = (H - pool)//stride + 1
    out_w = (W - pool)//stride + 1
    out = np.zeros((out_h, out_w), dtype=np.float32)
    for i in range(out_h):
        for j in range(out_w):
            r = i*stride
            c = j*stride
            window = img[r:r+pool, c:c+pool]
            out[i,j] = np.max(window)
    return out

pool1 = maxpool2d(relu1, pool=2, stride=2)  # 4x4
print("\n[Step 3] MaxPool(2x2, stride=2) output (4x4):")
print(np.round(pool1, 3))

plt.figure(figsize=(4,4))
plt.imshow(pool1, cmap="gray")
plt.title("Step 3: MaxPool (4x4)")
plt.axis("off")
plt.show()

# =========================
# 4) (요청대로) feature map에 다시 ReLU 적용 (이미 양수지만 단계 시연)
# =========================
relu2 = np.maximum(0.0, pool1)
print("\n[Step 4] ReLU(after Pool) output (4x4):")
print(np.round(relu2, 3))

plt.figure(figsize=(4,4))
plt.imshow(relu2, cmap="gray")
plt.title("Step 4: ReLU (4x4)")
plt.axis("off")
plt.show()

# =========================
# 5) 다시 Max Pooling (2x2, stride=2) → 2x2
# =========================
pool2 = maxpool2d(relu2, pool=2, stride=2)  # 2x2
print("\n[Step 5] MaxPool(2x2, stride=2) output (2x2):")
print(np.round(pool2, 3))

plt.figure(figsize=(3,3))
plt.imshow(pool2, cmap="gray")
plt.title("Step 5: MaxPool (2x2)")
plt.axis("off")
plt.show()

# =========================
# 6) 2x2 특징맵 → 1x4 특징벡터(flatten)
# =========================
feat_vec = pool2.reshape(1, -1)  # (1,4)
print("\n[Step 6] Flatten feature vector (1x4):")
print(np.round(feat_vec, 3))
plt.show()
