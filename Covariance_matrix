import numpy as np
import matplotlib.pyplot as plt

# Given data points (x, y)
data = np.array([(1, 1), (2, 2.5), (3, 2), (4, 4), (5, 3.5), (6, 3), (7, 3.5)])

# Calculating the standard deviations of each variable
std_dev_x = np.std(data[:, 0], ddof=1)  # Standard deviation of x
std_dev_y = np.std(data[:, 1], ddof=1)  # Standard deviation of y

print("Standard Deviation of x (s_x):", std_dev_x.round(3))
print("Standard Deviation of y (s_y):", std_dev_y.round(3))

# Calculating the covariance matrix
covariance_matrix = np.cov(data.T)

# Perform eigenvalue decomposition
eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)

# Calculating Pearson correlation matrix using numpy
corr_matrix = np.corrcoef(data.T)

#In a Pearson correlation matrix, the terms (1,1) and (2,2)- 
# which represent the correlation of a variable with itself â€” are always 1.0. 

# Displaying the results
print("Covariance Matrix:")
print(covariance_matrix.round(3))
print("\nEigenvalues:")
print(eigenvalues.round(3))

# Creating a diagonal matrix with the eigenvalues
diagonal_matrix = np.diag(eigenvalues)

print("Diagonal Matrix:")
print(diagonal_matrix.round(3))

print("\nEigenvectors:")
print(eigenvectors.round(3))
print("\nPearson_correlation_matrix :")
print(corr_matrix .round(3))

# Applying the Pearson correlation matrix to transform the data
transformed_data = data @ corr_matrix 
#transformed_data = data @ covariance_matrix

# Plotting the original and transformed data
plt.figure(figsize=(10, 5))

# Original data plot
plt.subplot(1, 2, 1)
plt.scatter(data[:, 0], data[:, 1], color='blue')
plt.title('Original Data')
plt.xlabel('X')
plt.ylabel('Y')

# Transformed data plot
plt.subplot(1, 2, 2)
plt.scatter(transformed_data[:, 0], transformed_data[:, 1], color='red')
plt.title('Transformed Data')
plt.xlabel('Transformed X')
plt.ylabel('Transformed Y')

plt.tight_layout()
plt.show()

# Plotting the data and the eigenvectors
#plt.figure(figsize=(6, 6))
#plt.scatter(data[:, 0], data[:, 1], color='blue', label='Data Points')

# Origin of the eigenvectors
origin = [0, 0]  # Using (0,0) as the origin for simplicity

# Plotting the eigenvectors
for vec in eigenvectors.T:
    plt.quiver(*origin, *vec, color='r', scale=1, scale_units='xy', angles='xy')

plt.xlim(-1, 1)
plt.ylim(0, 2)
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Data Points and Eigenvector Directions')
plt.axhline(0, color='black',linewidth=0.5)
plt.axvline(0, color='black',linewidth=0.5)
plt.grid(color='gray', linestyle='--', linewidth=0.5)
plt.legend()
plt.show()
