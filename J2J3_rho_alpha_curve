import numpy as np
import matplotlib.pyplot as plt

# ------------------------------------------------------------
# Plane stress: sigma3 = 0
# ------------------------------------------------------------
def mean_stress(s1, s2, s3=0.0):
    return (s1 + s2 + s3) / 3.0

def deviatoric_principal(s1, s2, s3=0.0):
    sm = mean_stress(s1, s2, s3)
    return s1 - sm, s2 - sm, s3 - sm

def J2_J3(s1, s2, s3=0.0):
    d1, d2, d3 = deviatoric_principal(s1, s2, s3)
    J2 = 0.5 * (d1**2 + d2**2 + d3**2)
    J3 = d1 * d2 * d3
    return J2, J3, (d1, d2, d3)

# ------------------------------------------------------------
# Kim–Van derivatives
# f = J2^3 + A*J3^2 + B*J2^(3/2)*J3 - k^6
# ------------------------------------------------------------
def df_dJ2(J2, J3, B):
    return 3.0*(J2**2) + 1.5*B*np.sqrt(J2)*J3

def df_dJ3(J2, J3, A, B):
    return 2.0*A*J3 + B*(J2**1.5)

# ------------------------------------------------------------
# Exact derivatives of invariants wrt principal stresses
# (NO division by s_i → works even when s_i = 0)
# ------------------------------------------------------------
def dJ2_dsigma(s1, s2, s3, which):
    return s1 if which == 1 else s2

def dJ3_dsigma(s1, s2, s3, which):
    if which == 1:   # ∂J3/∂σ1
        return (2/3)*s2*s3 - (1/3)*s1*s3 - (1/3)*s1*s2
    else:            # ∂J3/∂σ2
        return -(1/3)*s2*s3 + (2/3)*s1*s3 - (1/3)*s1*s2

# ------------------------------------------------------------
# r(alpha) = (dε2/dε1)
# ------------------------------------------------------------
def r_of_alpha(alpha_stress, A, B):
    sig1, sig2, sig3 = 1.0, alpha_stress, 0.0
    J2v, J3v, (s1, s2, s3d) = J2_J3(sig1, sig2, sig3)

    dfdJ2 = df_dJ2(J2v, J3v, B)
    dfdJ3 = df_dJ3(J2v, J3v, A, B)

    df_dsig1 = dfdJ2 * dJ2_dsigma(s1, s2, s3d, 1) \
             + dfdJ3 * dJ3_dsigma(s1, s2, s3d, 1)
    df_dsig2 = dfdJ2 * dJ2_dsigma(s1, s2, s3d, 2) \
             + dfdJ3 * dJ3_dsigma(s1, s2, s3d, 2)

    eps = 1e-12
    if abs(df_dsig1) < eps:
        return np.nan
    return df_dsig2 / df_dsig1

# ------------------------------------------------------------
# Solve alpha for a given r (single root, continuous branch)
# ------------------------------------------------------------
def solve_alpha_for_r(r_target, A, B, a_min=-2.0, a_max=2.0):
    alphas = np.linspace(a_min, a_max, 6000)
    rvals = np.array([r_of_alpha(a, A, B) for a in alphas])
    g = rvals - r_target

    for i in range(len(g)-1):
        if np.isfinite(g[i]) and np.isfinite(g[i+1]) and g[i]*g[i+1] < 0:
            lo, hi = alphas[i], alphas[i+1]
            for _ in range(60):
                mid = 0.5*(lo+hi)
                gm = r_of_alpha(mid, A, B) - r_target
                if abs(gm) < 1e-12:
                    return mid
                if (r_of_alpha(lo, A, B) - r_target) * gm <= 0:
                    hi = mid
                else:
                    lo = mid
            return 0.5*(lo+hi)
    return None

# ============================================================
# TEST: Mises case (A=0, B=0)
# ============================================================
A = 2.0
B = 0.0

r_list = np.linspace(1.0, -0.5, 46)

alpha_numeric = []
alpha_exact   = []

for r in r_list:
    a_num = solve_alpha_for_r(r, A, B)
    alpha_numeric.append(a_num)
    alpha_exact.append((1 + 2*r)/(2 + r))  # analytical Mises result

# ------------------------------------------------------------
# Plot comparison
# ------------------------------------------------------------


plt.figure(figsize=(7,5))

plt.plot(
    r_list,
    alpha_numeric,
    'o-',
    label=rf'Kim–Van Model ($A={A:.2f},\, B={B:.2f}$)'
)
plt.plot(
    r_list,
    alpha_exact,
    'k--',
    label='Analytical Mises (A=0, B=0)'
)

plt.xlabel(r"$r = d\varepsilon_2/d\varepsilon_1$", fontsize=13)
plt.ylabel(r"$\alpha = \sigma_2/\sigma_1$", fontsize=13)
plt.grid(True, linestyle=':')
plt.legend()
plt.title("Verification: Mises case")
plt.show()

# ------------------------------------------------------------
# Print table
# ------------------------------------------------------------
#print(" r        alpha (numerical)    alpha (analytical)")
#for r, an, ae in zip(r_list, alpha_numeric, alpha_exact):
#    print(f"{r: .2f}     {an: .6f}            {ae: .6f}")
