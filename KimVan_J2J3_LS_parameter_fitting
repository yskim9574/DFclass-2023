import numpy as np
from scipy.optimize import least_squares
import matplotlib.pyplot as plt
#데이타 출처: 김영석, 한국소성가공학회지, 30(6) (2021)
#J2J3 이방성항복조건식-12차식
plt.rcParams.update({
    'font.size': 12,          # 기본 글자 크기
    'axes.titlesize': 16,     # 제목 크기
    'axes.labelsize': 14,     # 축 이름 크기
    'xtick.labelsize': 14,    # x축 숫자 크기
    'ytick.labelsize': 14,    # y축 숫자 크기
    'legend.fontsize': 12,    # 범례 크기
    'figure.titlesize': 18    # 전체 피규어 제목 크기
})

# 1. 실험 데이터 설정
angles_deg = np.array([0, 15, 30, 45, 60, 75, 90])
exp_sigma = np.array([1.0, 1.006, 0.995, 0.982, 0.958, 0.949, 0.941])
exp_r = np.array([0.98, 0.75, 0.54, 0.38, 0.42, 0.58, 0.65])
exp_sigma_b = 1.01 

# 2. 핵심 계산 함수
def get_phi_and_derivatives(params, sx, sy, sxy):
    a = {1: params[0], 2: params[1], 3: params[2], 4: params[3]}
    b = {1: params[4], 2: params[5], 3: params[6], 4: params[7], 5: params[8], 10: params[9]}
    alpha, beta = params[10], params[11]

    j20 = (1/6) * ((a[1]+a[3])*sx**2 + (a[1]+a[2])*sy**2 - 2*a[1]*sx*sy) + a[4]*sxy**2
    j30 = (1/27)*((b[1]+b[2])*sx**3 + (b[3]+b[4])*sy**3) - (1/9)*(b[1]*sx + b[4]*sy)*sx*sy \
          + (1/3)*(b[5]*sy + (2*b[10]-b[5])*sx)*sxy**2
    phi = j20**6 + alpha*j30**4 + beta*(j20**3)*(j30**2)
    
    dj2_dsx = (a[1]+a[3])/3*sx - a[1]/3*sy
    dj2_dsy = (a[1]+a[2])/3*sy - a[1]/3*sx
    dj2_dsxy = 2*a[4]*sxy
    dj3_dsx = (b[1]/9)*(sx-sy)**2 + (b[2]/9)*sx**2 - (b[1]+b[4])/9*sy**2 + (2*b[10]-b[5])/3*sxy**2
    dj3_dsy = (b[4]/9)*(sy-sx)**2 + (b[3]/9)*sy**2 - (b[1]+b[4])/9*sx**2 + (b[5]/3)*sxy**2
    dj3_dsxy = (2/3)*sxy * (b[5]*sy + (2*b[10]-b[5])*sx)
    
    C = 6*(j20**5) + 3*beta*(j20**2)*(j30**2)
    D = 4*alpha*(j30**3) + 2*beta*(j20**3)*j30
    
    df_dsx = C*dj2_dsx + D*dj3_dsx
    df_dsy = C*dj2_dsy + D*dj3_dsy
    df_dsxy = C*dj2_dsxy + D*dj3_dsxy
    
    return phi, df_dsx, df_dsy, df_dsxy

# 3. 최적화 함수
def objective(params):
    k12 = (1/3)**6
    p_sigma, p_r = [], []
    for deg in angles_deg:
        th = np.radians(deg)
        c, s = np.cos(th), np.sin(th)
        phi, dfx, dfy, dfxy = get_phi_and_derivatives(params, c**2, s**2, s*c)
        p_sigma.append((phi/k12)**(-1/12))
        num = dfx*s**2 + dfy*c**2 - 0.5*dfxy*np.sin(2*th)
        p_r.append(-num / (dfx + dfy))
    phi_b, _, _, _ = get_phi_and_derivatives(params, exp_sigma_b, exp_sigma_b, 0)
    res_biaxial = (phi_b - k12) * 100.0
    return np.concatenate([(np.array(p_sigma)-exp_sigma)*10, (np.array(p_r)-exp_r)*1, [res_biaxial]])

# 최적화 실행
initial_guess = [1.039, 1.018, 0.729, 0.720, 0.722, 2.006, 2.825, 0.251, 1.574, 1.633, 1.546, 2.004]
result = least_squares(objective, initial_guess, method='lm')
opt = result.x

# 4. 시각화
fig, ax = plt.subplots(1, 3, figsize=(20, 6)) 
fine_ang = np.linspace(0, 90, 100)
ps, pr = [], []
k12 = (1/3)**6

for a_deg in fine_ang:
    th = np.radians(a_deg)
    phi, dfx, dfy, dfxy = get_phi_and_derivatives(opt, np.cos(th)**2, np.sin(th)**2, np.sin(th)*np.cos(th))
    ps.append((phi/k12)**(-1/12))
    pr.append(-(dfx*np.sin(th)**2 + dfy*np.cos(th)**2 - 0.5*dfxy*np.sin(2*th))/(dfx+dfy))

# (1) Yield Stress
ax[0].plot(fine_ang, ps, 'b-', linewidth=2, label='LM Optimized')
ax[0].plot(angles_deg, exp_sigma, 'ko', markersize=8, label='Exp Data')
ax[0].set_xticks([0, 15, 30, 45, 60, 75, 90])
ax[0].set_xlabel('Angle from RD (deg.)')
ax[0].set_ylabel(r'$\sigma_\theta / \sigma_0$')
ax[0].set_title('Directional Yield Stress')
ax[0].grid(True, ls=':')
ax[0].legend()
ax[0].set_ylim(0.91, 1.03) 

# (2) R-value
ax[1].plot(fine_ang, pr, 'r-', linewidth=2, label='LM Optimized')
ax[1].plot(angles_deg, exp_r, 'ko', markersize=8, label='Exp Data')
ax[1].set_xticks([0, 15, 30, 45, 60, 75, 90])
ax[1].set_xlabel('Angle from RD (deg.)')
ax[1].set_ylabel('$R$-value')
ax[1].set_title('Lankford Coefficient ($R_\\theta$)')
ax[1].grid(True, ls=':')
ax[1].legend()
ax[1].set_ylim(0.2, 1.2) 

# (3) Yield Surface
s_range = np.linspace(-1.5, 1.5, 200)
X, Y = np.meshgrid(s_range, s_range)
Z = np.zeros_like(X)
for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        val, _, _, _ = get_phi_and_derivatives(opt, X[i,j], Y[i,j], 0)
        Z[i,j] = val - k12

ax[2].contour(X, Y, Z, levels=[0], colors='blue', linewidths=2.5)
ax[2].contour(X, Y, (X**2-X*Y+Y**2)-1, levels=[0], colors='gray', linestyles='--')
ax[2].plot(exp_sigma_b, exp_sigma_b, 'rs', markersize=10, label=r'Exp $\sigma_b$') 
ax[2].axhline(0, color='k', lw=1.2); ax[2].axvline(0, color='k', lw=1.2)
ax[2].set_aspect('equal')
ax[2].set_xlabel(r'$\sigma_x / \sigma_0$')
ax[2].set_ylabel(r'$\sigma_y / \sigma_0$')
ax[2].set_title('Corrected Yield Surface')
ax[2].grid(True, ls=':')
ax[2].legend()

plt.tight_layout()
plt.show()

# 최종 파라미터 출력
param_names = ['a1','a2','a3','a4','b1','b2','b3','b4','b5','b10','alpha','beta']
print("=== Optimized Parameters ===")
for name, val in zip(param_names, opt):
    print(f"{name}: {val:.4f}")
